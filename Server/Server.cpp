// Server.cpp : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы.
//

#pragma comment (lib, "Ws2_32.lib") // Подключаем динамическую библиотеку ядра ОС
#include <winSock2.h> // Подключаем заголовочный файл, содержащий актуальные реализации функций для работы с сокетами
#include <iostream> // Подключаем стандартный библиотечный заголовочный файл для работы с потоками ввода-вывода (input-output streams)
#include <WS2tcpip.h> // Подключаем заголовочный файл, который содержит различные программные интерфейсы, связанные с работой протокола TCP/IP  (переводы различных данных в формат, понимаемый протоколом и т.д.)

SOCKET Connect; // Создаём сокет, который будет принимать подключаемых пользователей и будет передавать в большую коллекцию сокетов
SOCKET* Connections; // Создаём массив, в котором будут храниться все подключенные пользователи
SOCKET Listen; // Создаём сокет для подключения

int ClientCount = 0; // Счётчик количества подключаемых пользователей
void SendMessageToClient(int ID)
{
    char* buffer = new char[1024]; // Буфер, в котором будет временно храниться сообщение
    for (;; Sleep(75)) // Задаём циклу определенное время, чтобы не было перегрузки
    {
        memset(buffer, 0, sizeof(buffer));
        if (recv(Connections[ID], buffer, 1024, NULL)) // Цикл получает сообщение от пользователя, записывает его в буфер
        {
            printf(buffer); // Выводим сообщение
            printf("\n");
            for (int i = 0; i <= ClientCount; i++) // Отсылаем сообщение остальным клиентам
            {
                send(Connections[i], buffer, strlen(buffer), NULL); // Отправляем само сообщение сокету
            }
        }
    }
    delete buffer; // Чистим мусор из буфера
}

int main()
{
    setlocale(LC_ALL, "russian");
    WSAData/*тип данных*/ data; // Создаём структуру, в которую автоматически в момент создания загружаются данные о версии сокетов, используемых ОС, а также иная связанная системная информация
    WORD version = MAKEWORD(2, 2); // Указание диапазона версий реализации сокетов, которые мы хотим использовать и которые должны быть типа WORD
    int res = WSAStartup(version, &data); // Просит вас передать ей именно WORD, а она уже разложит значение переменной внутри по следующему алгоритму: функция считает, что в старшем байте слова указана минимальная версия реализации сокетов, которую хочет использовать пользователь, а в младшем – максимальная
    if (res != 0) // Проверяем, инициализировался ли сокет
    {
        return 0; // Если нет – выходим из функции
    }
    struct addrinfo hints; // Создаем переменные типа addrinfo, которые описывают информацию об адресе, используемом в TCP/IP
    struct addrinfo* result;

    Connections = (SOCKET*)calloc(64, sizeof(SOCKET));

    ZeroMemory(&hints, sizeof(hints));

    hints.ai_family = AF_INET; // Семейство протоколов
    hints.ai_flags = AI_PASSIVE; // Флаги
    hints.ai_socktype = SOCK_STREAM; // Тип сокета
    hints.ai_protocol = IPPROTO_TCP; // Протокол

    getaddrinfo(NULL, "7770", &hints, &result); // После чего задаем тип сокета через поля структуры addrinfo. Передаем порт, настройки сокета, результатную информацию о сокете

    Listen = socket(result->ai_family, result->ai_socktype, result->ai_protocol); // Настраиваем сокет Listen и объявляем сервер с помощью функции bind()

    bind(Listen, result->ai_addr, result->ai_addrlen);
    listen(Listen, SOMAXCONN);

    freeaddrinfo(result);

    printf("Start server...");
    char m_connect[] = "Connect...";

    for (;; Sleep(75)) // Запускаем бесконечный цикл подключения клиентов
    {
        if (Connect = accept(Listen, NULL, NULL))
        {
            printf("Client connect...\n");
            Connections[ClientCount] = Connect;
            send(Connections[ClientCount], m_connect, strlen(m_connect), NULL);
            ClientCount++;
            CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)SendMessageToClient, (LPVOID)(ClientCount - 1), NULL, NULL);
        }
    }
    return 1;
}

// Запуск программы: CTRL+F5 или меню "Отладка" > "Запуск без отладки"
// Отладка программы: F5 или меню "Отладка" > "Запустить отладку"

// Советы по началу работы 
//   1. В окне обозревателя решений можно добавлять файлы и управлять ими.
//   2. В окне Team Explorer можно подключиться к системе управления версиями.
//   3. В окне "Выходные данные" можно просматривать выходные данные сборки и другие сообщения.
//   4. В окне "Список ошибок" можно просматривать ошибки.
//   5. Последовательно выберите пункты меню "Проект" > "Добавить новый элемент", чтобы создать файлы кода, или "Проект" > "Добавить существующий элемент", чтобы добавить в проект существующие файлы кода.
//   6. Чтобы снова открыть этот проект позже, выберите пункты меню "Файл" > "Открыть" > "Проект" и выберите SLN-файл.
